// @generated by protoc-gen-es v2.2.3 with parameter "target=js+dts,import_extension=none,json_types=true"
// @generated from file cassie/eval.proto (syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file cassie/eval.proto.
 */
export declare const file_cassie_eval: GenFile;

/**
 * -------------------------------------------------------------------------
 * Assertions
 * -------------------------------------------------------------------------
 *
 * @generated from message Assertion
 */
export declare type Assertion = Message<"Assertion"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: Assertion.Type type = 2;
   */
  type: Assertion_Type;

  /**
   * @generated from field: Assertion.Result result = 3;
   */
  result: Assertion_Result;

  /**
   * Exactly one concrete assertion payload must be present.
   *
   * @generated from oneof Assertion.payload
   */
  payload: {
    /**
     * @generated from field: Assertion.ShellRequiredFlag shell_required_flag = 4;
     */
    value: Assertion_ShellRequiredFlag;
    case: "shellRequiredFlag";
  } | {
    /**
     * @generated from field: Assertion.ToolInvocation tool_invocation = 5;
     */
    value: Assertion_ToolInvocation;
    case: "toolInvocation";
  } | {
    /**
     * @generated from field: Assertion.FileRetrieval file_retrieval = 6;
     */
    value: Assertion_FileRetrieval;
    case: "fileRetrieval";
  } | {
    /**
     * @generated from field: Assertion.LLMJudge llm_judge = 7;
     */
    value: Assertion_LLMJudge;
    case: "llmJudge";
  } | {
    /**
     * @generated from field: Assertion.CodeblockRegex codeblock_regex = 8;
     */
    value: Assertion_CodeblockRegex;
    case: "codeblockRegex";
  } | { case: undefined; value?: undefined };

  /**
   * If the assertion failed, this will contain the reason.
   *
   * @generated from field: string failure_reason = 9;
   */
  failureReason: string;
};

/**
 * -------------------------------------------------------------------------
 * Assertions
 * -------------------------------------------------------------------------
 *
 * @generated from message Assertion
 */
export declare type AssertionJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: Assertion.Type type = 2;
   */
  type?: Assertion_TypeJson;

  /**
   * @generated from field: Assertion.Result result = 3;
   */
  result?: Assertion_ResultJson;

  /**
   * @generated from field: Assertion.ShellRequiredFlag shell_required_flag = 4;
   */
  shellRequiredFlag?: Assertion_ShellRequiredFlagJson;

  /**
   * @generated from field: Assertion.ToolInvocation tool_invocation = 5;
   */
  toolInvocation?: Assertion_ToolInvocationJson;

  /**
   * @generated from field: Assertion.FileRetrieval file_retrieval = 6;
   */
  fileRetrieval?: Assertion_FileRetrievalJson;

  /**
   * @generated from field: Assertion.LLMJudge llm_judge = 7;
   */
  llmJudge?: Assertion_LLMJudgeJson;

  /**
   * @generated from field: Assertion.CodeblockRegex codeblock_regex = 8;
   */
  codeblockRegex?: Assertion_CodeblockRegexJson;

  /**
   * If the assertion failed, this will contain the reason.
   *
   * @generated from field: string failure_reason = 9;
   */
  failureReason?: string;
};

/**
 * Describes the message Assertion.
 * Use `create(AssertionSchema)` to create a new message.
 */
export declare const AssertionSchema: GenMessage<Assertion, AssertionJson>;

/**
 * Verifies that a shell command includes specific flags.
 *
 * @generated from message Assertion.ShellRequiredFlag
 */
export declare type Assertion_ShellRequiredFlag = Message<"Assertion.ShellRequiredFlag"> & {
  /**
   * e.g. "kubectl"
   *
   * @generated from field: string command = 1;
   */
  command: string;

  /**
   * e.g. ["--context"]
   *
   * @generated from field: repeated string flags = 2;
   */
  flags: string[];
};

/**
 * Verifies that a shell command includes specific flags.
 *
 * @generated from message Assertion.ShellRequiredFlag
 */
export declare type Assertion_ShellRequiredFlagJson = {
  /**
   * e.g. "kubectl"
   *
   * @generated from field: string command = 1;
   */
  command?: string;

  /**
   * e.g. ["--context"]
   *
   * @generated from field: repeated string flags = 2;
   */
  flags?: string[];
};

/**
 * Describes the message Assertion.ShellRequiredFlag.
 * Use `create(Assertion_ShellRequiredFlagSchema)` to create a new message.
 */
export declare const Assertion_ShellRequiredFlagSchema: GenMessage<Assertion_ShellRequiredFlag, Assertion_ShellRequiredFlagJson>;

/**
 * Verifies that a tool **is** or **is not** invoked.
 *
 * @generated from message Assertion.ToolInvocation
 */
export declare type Assertion_ToolInvocation = Message<"Assertion.ToolInvocation"> & {
  /**
   * e.g. "file_search"
   *
   * @generated from field: string tool_name = 1;
   */
  toolName: string;
};

/**
 * Verifies that a tool **is** or **is not** invoked.
 *
 * @generated from message Assertion.ToolInvocation
 */
export declare type Assertion_ToolInvocationJson = {
  /**
   * e.g. "file_search"
   *
   * @generated from field: string tool_name = 1;
   */
  toolName?: string;
};

/**
 * Describes the message Assertion.ToolInvocation.
 * Use `create(Assertion_ToolInvocationSchema)` to create a new message.
 */
export declare const Assertion_ToolInvocationSchema: GenMessage<Assertion_ToolInvocation, Assertion_ToolInvocationJson>;

/**
 * Verifies that a file **is** or **is not** retrieved.
 *
 * @generated from message Assertion.FileRetrieval
 */
export declare type Assertion_FileRetrieval = Message<"Assertion.FileRetrieval"> & {
  /**
   * @generated from field: string file_id = 1;
   */
  fileId: string;

  /**
   * Optional human-readable name
   *
   * @generated from field: string file_name = 2;
   */
  fileName: string;
};

/**
 * Verifies that a file **is** or **is not** retrieved.
 *
 * @generated from message Assertion.FileRetrieval
 */
export declare type Assertion_FileRetrievalJson = {
  /**
   * @generated from field: string file_id = 1;
   */
  fileId?: string;

  /**
   * Optional human-readable name
   *
   * @generated from field: string file_name = 2;
   */
  fileName?: string;
};

/**
 * Describes the message Assertion.FileRetrieval.
 * Use `create(Assertion_FileRetrievalSchema)` to create a new message.
 */
export declare const Assertion_FileRetrievalSchema: GenMessage<Assertion_FileRetrieval, Assertion_FileRetrievalJson>;

/**
 * Asks an LLM to grade the assistant's answer.
 *
 * @generated from message Assertion.LLMJudge
 */
export declare type Assertion_LLMJudge = Message<"Assertion.LLMJudge"> & {
  /**
   * @generated from field: string prompt = 1;
   */
  prompt: string;
};

/**
 * Asks an LLM to grade the assistant's answer.
 *
 * @generated from message Assertion.LLMJudge
 */
export declare type Assertion_LLMJudgeJson = {
  /**
   * @generated from field: string prompt = 1;
   */
  prompt?: string;
};

/**
 * Describes the message Assertion.LLMJudge.
 * Use `create(Assertion_LLMJudgeSchema)` to create a new message.
 */
export declare const Assertion_LLMJudgeSchema: GenMessage<Assertion_LLMJudge, Assertion_LLMJudgeJson>;

/**
 * Checks if at least one code block matches the regex.
 *
 * @generated from message Assertion.CodeblockRegex
 */
export declare type Assertion_CodeblockRegex = Message<"Assertion.CodeblockRegex"> & {
  /**
   * The regex pattern to match against code blocks
   *
   * @generated from field: string regex = 1;
   */
  regex: string;
};

/**
 * Checks if at least one code block matches the regex.
 *
 * @generated from message Assertion.CodeblockRegex
 */
export declare type Assertion_CodeblockRegexJson = {
  /**
   * The regex pattern to match against code blocks
   *
   * @generated from field: string regex = 1;
   */
  regex?: string;
};

/**
 * Describes the message Assertion.CodeblockRegex.
 * Use `create(Assertion_CodeblockRegexSchema)` to create a new message.
 */
export declare const Assertion_CodeblockRegexSchema: GenMessage<Assertion_CodeblockRegex, Assertion_CodeblockRegexJson>;

/**
 * What we are checking for.
 *
 * @generated from enum Assertion.Type
 */
export enum Assertion_Type {
  /**
   * @generated from enum value: TYPE_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Were all required CLI flags present?
   *
   * @generated from enum value: TYPE_SHELL_REQUIRED_FLAG = 1;
   */
  SHELL_REQUIRED_FLAG = 1,

  /**
   * Was a tool invoked (or not)?
   *
   * @generated from enum value: TYPE_TOOL_INVOKED = 2;
   */
  TOOL_INVOKED = 2,

  /**
   * Was a file retrieved (or not)?
   *
   * @generated from enum value: TYPE_FILE_RETRIEVED = 3;
   */
  FILE_RETRIEVED = 3,

  /**
   * Ask an LLM to grade the final answer.
   *
   * @generated from enum value: TYPE_LLM_JUDGE = 4;
   */
  LLM_JUDGE = 4,

  /**
   * Does at least one code block match the regex?
   *
   * @generated from enum value: TYPE_CODEBLOCK_REGEX = 5;
   */
  CODEBLOCK_REGEX = 5,
}

/**
 * What we are checking for.
 *
 * @generated from enum Assertion.Type
 */
export declare type Assertion_TypeJson = "TYPE_UNKNOWN" | "TYPE_SHELL_REQUIRED_FLAG" | "TYPE_TOOL_INVOKED" | "TYPE_FILE_RETRIEVED" | "TYPE_LLM_JUDGE" | "TYPE_CODEBLOCK_REGEX";

/**
 * Describes the enum Assertion.Type.
 */
export declare const Assertion_TypeSchema: GenEnum<Assertion_Type, Assertion_TypeJson>;

/**
 * Outcome of an assertion after a test run.
 *
 * @generated from enum Assertion.Result
 */
export enum Assertion_Result {
  /**
   * @generated from enum value: RESULT_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: RESULT_TRUE = 1;
   */
  TRUE = 1,

  /**
   * @generated from enum value: RESULT_FALSE = 2;
   */
  FALSE = 2,

  /**
   * @generated from enum value: RESULT_SKIPPED = 3;
   */
  SKIPPED = 3,
}

/**
 * Outcome of an assertion after a test run.
 *
 * @generated from enum Assertion.Result
 */
export declare type Assertion_ResultJson = "RESULT_UNKNOWN" | "RESULT_TRUE" | "RESULT_FALSE" | "RESULT_SKIPPED";

/**
 * Describes the enum Assertion.Result.
 */
export declare const Assertion_ResultSchema: GenEnum<Assertion_Result, Assertion_ResultJson>;

/**
 * -------------------------------------------------------------------------
 * EvalSample – Represents a single evaluation input and its expected assertions
 * -------------------------------------------------------------------------
 *
 * @generated from message EvalSample
 */
export declare type EvalSample = Message<"EvalSample"> & {
  /**
   * Resource kind, always "EvalSample"
   *
   * @generated from field: string kind = 1;
   */
  kind: string;

  /**
   * Standard metadata (name, labels, etc.)
   *
   * @generated from field: ObjectMeta metadata = 2;
   */
  metadata?: ObjectMeta;

  /**
   * The input text to be evaluated
   *
   * @generated from field: string input_text = 3;
   */
  inputText: string;

  /**
   * List of assertions to check for this input
   *
   * @generated from field: repeated Assertion assertions = 4;
   */
  assertions: Assertion[];
};

/**
 * -------------------------------------------------------------------------
 * EvalSample – Represents a single evaluation input and its expected assertions
 * -------------------------------------------------------------------------
 *
 * @generated from message EvalSample
 */
export declare type EvalSampleJson = {
  /**
   * Resource kind, always "EvalSample"
   *
   * @generated from field: string kind = 1;
   */
  kind?: string;

  /**
   * Standard metadata (name, labels, etc.)
   *
   * @generated from field: ObjectMeta metadata = 2;
   */
  metadata?: ObjectMetaJson;

  /**
   * The input text to be evaluated
   *
   * @generated from field: string input_text = 3;
   */
  inputText?: string;

  /**
   * List of assertions to check for this input
   *
   * @generated from field: repeated Assertion assertions = 4;
   */
  assertions?: AssertionJson[];
};

/**
 * Describes the message EvalSample.
 * Use `create(EvalSampleSchema)` to create a new message.
 */
export declare const EvalSampleSchema: GenMessage<EvalSample, EvalSampleJson>;

/**
 * @generated from message EvalDataset
 */
export declare type EvalDataset = Message<"EvalDataset"> & {
  /**
   * @generated from field: repeated EvalSample samples = 1;
   */
  samples: EvalSample[];
};

/**
 * @generated from message EvalDataset
 */
export declare type EvalDatasetJson = {
  /**
   * @generated from field: repeated EvalSample samples = 1;
   */
  samples?: EvalSampleJson[];
};

/**
 * Describes the message EvalDataset.
 * Use `create(EvalDatasetSchema)` to create a new message.
 */
export declare const EvalDatasetSchema: GenMessage<EvalDataset, EvalDatasetJson>;

/**
 * @generated from message ObjectMeta
 */
export declare type ObjectMeta = Message<"ObjectMeta"> & {
  /**
   * Name of the resource, e.g. "experiment-test".
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * @generated from message ObjectMeta
 */
export declare type ObjectMetaJson = {
  /**
   * Name of the resource, e.g. "experiment-test".
   *
   * @generated from field: string name = 1;
   */
  name?: string;
};

/**
 * Describes the message ObjectMeta.
 * Use `create(ObjectMetaSchema)` to create a new message.
 */
export declare const ObjectMetaSchema: GenMessage<ObjectMeta, ObjectMetaJson>;

/**
 * @generated from message ExperimentSpec
 */
export declare type ExperimentSpec = Message<"ExperimentSpec"> & {
  /**
   * Path to the folder containing the dataset to evaluate.
   *
   * @generated from field: string dataset_path = 1;
   */
  datasetPath: string;

  /**
   * Directory where experiment reports will be written.
   *
   * @generated from field: string output_dir = 2;
   */
  outputDir: string;

  /**
   * URL of the backend inference service to call during evaluation.
   *
   * @generated from field: string inference_endpoint = 3;
   */
  inferenceEndpoint: string;
};

/**
 * @generated from message ExperimentSpec
 */
export declare type ExperimentSpecJson = {
  /**
   * Path to the folder containing the dataset to evaluate.
   *
   * @generated from field: string dataset_path = 1;
   */
  datasetPath?: string;

  /**
   * Directory where experiment reports will be written.
   *
   * @generated from field: string output_dir = 2;
   */
  outputDir?: string;

  /**
   * URL of the backend inference service to call during evaluation.
   *
   * @generated from field: string inference_endpoint = 3;
   */
  inferenceEndpoint?: string;
};

/**
 * Describes the message ExperimentSpec.
 * Use `create(ExperimentSpecSchema)` to create a new message.
 */
export declare const ExperimentSpecSchema: GenMessage<ExperimentSpec, ExperimentSpecJson>;

/**
 * @generated from message Experiment
 */
export declare type Experiment = Message<"Experiment"> & {
  /**
   * API version of the resource, e.g. "cloudassistant.io/v1alpha1".
   *
   * @generated from field: string api_version = 1;
   */
  apiVersion: string;

  /**
   * Kind of the resource. Always "Experiment" for this CRD.
   *
   * @generated from field: string kind = 2;
   */
  kind: string;

  /**
   * Standard Kubernetes object metadata (name, labels, annotations, etc.).
   *
   * @generated from field: ObjectMeta metadata = 3;
   */
  metadata?: ObjectMeta;

  /**
   * User-defined configuration for the experiment.
   *
   * @generated from field: ExperimentSpec spec = 4;
   */
  spec?: ExperimentSpec;
};

/**
 * @generated from message Experiment
 */
export declare type ExperimentJson = {
  /**
   * API version of the resource, e.g. "cloudassistant.io/v1alpha1".
   *
   * @generated from field: string api_version = 1;
   */
  apiVersion?: string;

  /**
   * Kind of the resource. Always "Experiment" for this CRD.
   *
   * @generated from field: string kind = 2;
   */
  kind?: string;

  /**
   * Standard Kubernetes object metadata (name, labels, annotations, etc.).
   *
   * @generated from field: ObjectMeta metadata = 3;
   */
  metadata?: ObjectMetaJson;

  /**
   * User-defined configuration for the experiment.
   *
   * @generated from field: ExperimentSpec spec = 4;
   */
  spec?: ExperimentSpecJson;
};

/**
 * Describes the message Experiment.
 * Use `create(ExperimentSchema)` to create a new message.
 */
export declare const ExperimentSchema: GenMessage<Experiment, ExperimentJson>;

